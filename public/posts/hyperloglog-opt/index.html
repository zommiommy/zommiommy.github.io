<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Optimizing HyperLogLog
    </title><link href=/corro.svg rel=icon type=image/png><link href=https://zom.wtf/fonts.css rel=stylesheet><link href=/path/to/folder/css/academicons.min.css rel=stylesheet><link href=https://zom.wtf/atom.xml rel=alternate title=zom.wtf type=application/atom+xml><link href=https://zom.wtf/theme/light.css rel=stylesheet><link href=https://zom.wtf/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><img id=title_icon src=/corro.svg><a href=https://zom.wtf>zom.wtf</a><div class=socials><a class=social href=https://twitter.com/zommiommy> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/zommiommy> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/about style=margin-left:.7em>/about</a><a href=/goodstuff style=margin-left:.7em>/good_stuff</a></nav></header><main><article><div class=title><div class=page-header>Optimizing HyperLogLog</div><div class=meta>Posted on <time>2023-05-12</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://zom.wtf/posts/hyperloglog-opt/#hyperloglog>HyperLogLog</a> <ul><li><a href=https://zom.wtf/posts/hyperloglog-opt/#naive-implementation>Naive implementation</a><li><a href=https://zom.wtf/posts/hyperloglog-opt/#avoiding-the-call-to-ldexpf>Avoiding the call to ldexpf</a><li><a href=https://zom.wtf/posts/hyperloglog-opt/#avoiding-divisions>Avoiding Divisions</a><li><a href=https://zom.wtf/posts/hyperloglog-opt/#ieee-754-tricks>IEEE 754 tricks</a><li><a href=https://zom.wtf/posts/hyperloglog-opt/#fixed-point-for-precision-and-profit>Fixed point for precision and profit</a><li><a href=https://zom.wtf/posts/hyperloglog-opt/#benchmarks>Benchmarks</a><li><a href=https://zom.wtf/posts/hyperloglog-opt/#reference>Reference</a></ul></ul><section class=body><h1 id=hyperloglog>HyperLogLog</h1><p><a href=https://en.wikipedia.org/wiki/HyperLogLog>HyperLogLog counters</a> are a smart way to <strong>estimate</strong> the number of <strong>uniques</strong> elements seen in a stream. They exploit the fact that the number (N) of leading (or trailing) zeros (or ones), on a random number follows a geometric distribution of parameter \(p = \frac{1}{2}\), i.e.:<p>\[P(N = n) \propto \frac{1}{2^{n}}\]<p>The jist of the HyperLogLog counters is to use an hash function on the values and keep track of the maximum number of leading zeros. To be more resiliant to outliers, multiple buckets are used. The first few bits are used to pick in which bucket each hashed value belongs to. In order to compute the caradinality estimate, we take the <a href=https://en.wikipedia.org/wiki/Harmonic_mean><strong>harmonic mean</strong></a> of the value of each bucket:<p>\[|C| \approx \left( \sum_i \frac{1}{2^{x_i}} \right)^{-1}\]<p>In this post I'll explore the different implementations I experimented with to optimize this simple but fundamental operation.<h3 id=naive-implementation>Naive implementation</h3><p>This is the simplest way to compute it.<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>let mut</span><span> total</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>f32 </span><span style=color:#f29668>= </span><span style=color:#f29718>0.0</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>for</span><span> value </span><span style=color:#f29668>in</span><span> values {
</span><span>    total </span><span style=color:#f29668>+= </span><span style=color:#f29718>1.0 </span><span style=color:#f29668>/ </span><span style=color:#f29718>2.0</span><span style=color:#f29668>.</span><span style=color:#f07178>powf</span><span>(value </span><span style=color:#f29668>as </span><span style=color:#ff7733>f32</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>The assembly inside the loop looks like this:<pre class=language-asm data-lang=asm style=background:#0f1419;color:#bfbab0><code class=language-asm data-lang=asm><span style=color:#ff7733>movzx  </span><span style=color:#f29718>edi</span><span>, </span><span style=color:#f07178>byte ptr </span><span>[</span><span style=color:#f29718>r14 </span><span>+ </span><span style=color:#f29718>r15</span><span>],</span><span style=font-style:italic;color:#5c6773>    ; Load `value` from `values`
</span><span style=color:#ff7733>vmovss </span><span style=color:#f29718>xmm0</span><span>, </span><span style=color:#f07178>dword ptr </span><span>[</span><span style=color:#f29718>rip </span><span>+ </span><span style=color:#ffb454>.TWO</span><span>]</span><span style=font-style:italic;color:#5c6773>  ; Load 2.0
</span><span style=color:#ff7733>call   </span><span style=color:#f29718>r12</span><span style=font-style:italic;color:#5c6773>                           ; Call ldexpf -> xmm0 = 2.0^values
</span><span style=color:#ff7733>vmovss </span><span style=color:#f29718>xmm1</span><span>, </span><span style=color:#f07178>dword ptr </span><span>[</span><span style=color:#f29718>rip </span><span>+ </span><span style=color:#ffb454>.ONE</span><span>]</span><span style=font-style:italic;color:#5c6773>  ; Load 1.0
</span><span style=color:#ff7733>vdivss </span><span style=color:#f29718>xmm0</span><span>, </span><span style=color:#f29718>xmm1</span><span>, </span><span style=color:#f29718>xmm0</span><span style=font-style:italic;color:#5c6773>              ; 1.0 / 2.0^value
</span><span style=color:#ffb454>vadds  </span><span style=color:#f29718>xmm2</span><span>, </span><span style=color:#f29718>xmm1</span><span>, </span><span style=color:#f29718>xmm0</span><span style=font-style:italic;color:#5c6773>              ; total +=
</span></code></pre><h3 id=avoiding-the-call-to-ldexpf>Avoiding the call to ldexpf</h3><p>Having a call in the function adds a lot of overhead so we can avoid it this way:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>let mut</span><span> total</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>f32 </span><span style=color:#f29668>= </span><span style=color:#f29718>0.0</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>for</span><span> value </span><span style=color:#f29668>in</span><span> values {
</span><span>    total </span><span style=color:#f29668>+= </span><span style=color:#f29718>1.0 </span><span style=color:#f29668>/ </span><span>((</span><span style=color:#f29718>1 </span><span style=color:#f29668><<</span><span> value) </span><span style=color:#f29668>as </span><span style=color:#ff7733>f32</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>The assembly inside the loop looks like this:<pre class=language-asm data-lang=asm style=background:#0f1419;color:#bfbab0><code class=language-asm data-lang=asm><span style=color:#ff7733>movzx </span><span style=color:#f29718>r8d</span><span>, </span><span style=color:#f07178>byte ptr </span><span>[</span><span style=color:#f29718>rax</span><span>]</span><span style=font-style:italic;color:#5c6773> ; Load `value` from `values`
</span><span style=color:#ff7733>mov   </span><span style=color:#f29718>edx</span><span>, </span><span style=color:#f29718>1</span><span style=font-style:italic;color:#5c6773>              ; 1
</span><span style=color:#ffb454>shlx  </span><span style=color:#f29718>r8d</span><span>, </span><span style=color:#f29718>edx</span><span>, </span><span style=color:#ffb454>e8d</span><span style=font-style:italic;color:#5c6773>       ; 1 << value ;  3 cycles
</span><span style=color:#ff7733>vcvtsi2ss </span><span style=color:#f29718>xmm2</span><span>, </span><span style=color:#f29718>xmm3</span><span>, </span><span style=color:#f29718>r8d</span><span style=font-style:italic;color:#5c6773> ; as f32     ;  8 cycles
</span><span style=color:#ff7733>vdivss </span><span style=color:#f29718>xmm2</span><span>, </span><span style=color:#f29718>xmm1</span><span>, </span><span style=color:#f29718>xmm2</span><span style=font-style:italic;color:#5c6773>   ; 1.0 /      ; 18 cycles
</span><span style=color:#ff7733>vaddss  </span><span style=color:#f29718>xmm0</span><span>, </span><span style=color:#f29718>xmm0</span><span>, </span><span style=color:#f29718>xmm2</span><span style=font-style:italic;color:#5c6773>  ; total +=   ;  3 cycles
</span></code></pre><h3 id=avoiding-divisions>Avoiding Divisions</h3><p>One way to avoid division is to pre-compute all the values and look them. Assuming that the table in in the L1 Cache we can avoid the division and the conversion to f32, trading 18 + 8 = 26 cycles for a memory read which is about 10 cycles.<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>let mut</span><span> total</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>f32 </span><span style=color:#f29668>= </span><span style=color:#f29718>0.0</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>for</span><span> value </span><span style=color:#f29668>in</span><span> values {
</span><span>    total </span><span style=color:#f29668>+= </span><span style=color:#f29718>RECIPROCALS_TABLE</span><span>[value </span><span style=color:#f29668>as </span><span style=color:#ff7733>usize</span><span>]</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>The assembly inside the loop looks like this:<pre class=language-asm data-lang=asm style=background:#0f1419;color:#bfbab0><code class=language-asm data-lang=asm><span style=color:#ff7733>movzx </span><span style=color:#f29718>r8d</span><span>, </span><span style=color:#f07178>byte ptr </span><span>[</span><span style=color:#f29718>rax</span><span>]</span><span style=font-style:italic;color:#5c6773>  ; Load `value` from `values`
</span><span style=color:#ff7733>movd </span><span style=color:#f29718>xmm2</span><span>, </span><span style=color:#f07178>ptr </span><span>[</span><span style=color:#f29718>r12 </span><span>+ </span><span style=color:#f29718>r8d</span><span>]</span><span style=font-style:italic;color:#5c6773> ; RECIPROCALS_TABLE ; ~10 cycles 
</span><span style=color:#ff7733>vaddss  </span><span style=color:#f29718>xmm0</span><span>, </span><span style=color:#f29718>xmm0</span><span>, </span><span style=color:#f29718>xmm2</span><span style=font-style:italic;color:#5c6773>   ; total +=          ;   3 cycles
</span></code></pre><h3 id=ieee-754-tricks>IEEE 754 tricks</h3><p>The <a href=https://en.wikipedia.org/wiki/IEEE_754>IEEE 754 floats</a>, we use and love everyday, represents values as: <img alt src=https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Float_example.svg/1024px-Float_example.svg.png><p>where a value is decoded as: \[\text{value} = \text{sign}() \cdot (1 + \text{fraction}) \cdot 2^{127 + \text{exponent}}\]<p>So with a bit of bit trickery we can directly build the value with just a sum and a shift:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>let mut</span><span> total</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>f32 </span><span style=color:#f29668>= </span><span style=color:#f29718>0.0</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>for</span><span> value </span><span style=color:#f29668>in</span><span> values {
</span><span>    </span><span style=color:#ff7733>let</span><span> hack </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>127 </span><span style=color:#f29668>+</span><span> value </span><span style=color:#f29668>as </span><span style=color:#ff7733>u32</span><span>) </span><span style=color:#f29668><< </span><span style=color:#f29718>23</span><span style=color:#bfbab0cc>;
</span><span>    total </span><span style=color:#f29668>+= </span><span style=color:#ff7733>f32</span><span style=color:#f29668>::</span><span>from_ne_bytes(hack</span><span style=color:#f29668>.</span><span style=color:#f07178>to_ne_bytes</span><span>())</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>The assembly inside the loop looks like this:<pre class=language-asm data-lang=asm style=background:#0f1419;color:#bfbab0><code class=language-asm data-lang=asm><span style=color:#ff7733>movzx </span><span style=color:#f29718>edx</span><span>, </span><span style=color:#f07178>byte ptr </span><span>[</span><span style=color:#f29718>rax</span><span>]</span><span style=font-style:italic;color:#5c6773> ; Load `value` from `values`
</span><span style=color:#ff7733>shl   </span><span style=color:#f29718>edx</span><span>, </span><span style=color:#f29718>23</span><span style=font-style:italic;color:#5c6773>             ; << 23         ; 1 cycle
</span><span style=color:#ff7733>add </span><span style=color:#f29718>ecx</span><span>, </span><span style=color:#f29718>1065353216</span><span style=font-style:italic;color:#5c6773>       ; + (127 << 23) ; 1 cycle
</span><span style=color:#ff7733>movd </span><span style=color:#f29718>xmm1</span><span>, </span><span style=color:#f29718>ecx</span><span style=font-style:italic;color:#5c6773>            ; as f32        ; 3 cycles
</span><span style=color:#ff7733>vaddss </span><span style=color:#f29718>xmm0</span><span>, </span><span style=color:#f29718>xmm0</span><span>, </span><span style=color:#f29718>xmm1</span><span style=font-style:italic;color:#5c6773>   ; total +=      ; 3 cycles
</span></code></pre><h3 id=fixed-point-for-precision-and-profit>Fixed point for precision and profit</h3><p>If we assume that the values are less or equal than 32, we can use an u64 word as a <a href=https://en.wikipedia.org/wiki/Fixed-point_arithmetic>fixed point precision</a> value with 32 decimal bits. This allows us to compute the exact result with no loss of resolution and further speed up the code.<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>let mut</span><span> counter</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>u64 </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>for</span><span> value </span><span style=color:#f29668>in</span><span> values {
</span><span>    counter </span><span style=color:#f29668>+= </span><span>(</span><span style=color:#f29718>1_</span><span style=color:#ff7733>u64 </span><span style=color:#f29668><< </span><span style=color:#f29718>32</span><span>) </span><span style=color:#f29668>>></span><span> value</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span style=color:#ff7733>let</span><span> exp </span><span style=color:#f29668>=</span><span> counter</span><span style=color:#f29668>.</span><span style=color:#f07178>leading_zeros</span><span>() </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>counter </span><span style=color:#f29668><<=</span><span> exp</span><span style=color:#bfbab0cc>;
</span><span>counter </span><span style=color:#f29668>>>= </span><span style=color:#f29718>64 </span><span style=color:#f29668>- </span><span style=color:#f29718>23</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>let</span><span> res </span><span style=color:#f29668>= </span><span>(((</span><span style=color:#f29718>127 </span><span style=color:#f29668>+ </span><span style=color:#f29718>32 </span><span style=color:#f29668>-</span><span> exp) </span><span style=color:#f29668>as </span><span style=color:#ff7733>u32</span><span>) </span><span style=color:#f29668><< </span><span style=color:#f29718>23</span><span>) </span><span style=color:#f29668>| </span><span>(counter </span><span style=color:#f29668>as </span><span style=color:#ff7733>u32</span><span>)</span><span style=color:#bfbab0cc>;
</span><span style=color:#ff7733>let</span><span> estimate </span><span style=color:#f29668>= </span><span style=color:#ff7733>f32</span><span style=color:#f29668>::</span><span>from_ne_bytes(res</span><span style=color:#f29668>.</span><span style=color:#f07178>to_ne_bytes</span><span>())</span><span style=color:#bfbab0cc>;
</span></code></pre><p>The assembly inside the loop looks like this:<pre class=language-asm data-lang=asm style=background:#0f1419;color:#bfbab0><code class=language-asm data-lang=asm><span style=color:#ff7733>movzx </span><span style=color:#f29718>esi</span><span>, </span><span style=color:#f07178>byte ptr </span><span>[</span><span style=color:#f29718>rax</span><span>]</span><span style=font-style:italic;color:#5c6773>   ; Load `value` from `values`
</span><span style=color:#ffb454>shrx </span><span style=color:#f29718>rsi</span><span>, </span><span style=color:#f29718>rcx</span><span>, </span><span style=color:#f29718>rsi</span><span style=font-style:italic;color:#5c6773>          ; <<         ; 3 cycles
</span><span style=color:#ff7733>add </span><span style=color:#f29718>rdx</span><span>, </span><span style=color:#f29718>rsi</span><span style=font-style:italic;color:#5c6773>                ; counter += ; 1 cycle
</span></code></pre><h2 id=benchmarks>Benchmarks</h2><p>Computing the sum of 10'000 elements (between 0 and 32) on my <code>Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz</code><table><thead><tr><th>Impl<th>ns / element<th>speedup<tbody><tr><td>naive<td>9.2354<td>/<tr><td>no call<td>1.4025<td>6.58<tr><td>table<td>1.1763<td>7.85<tr><td>IEE 754<td>1.1586<td>7.97<tr><td>Fixed Point<td>0.5693<td>16.22</table><p>And compiling with <code>RUSTFLAGS="-C target-cpu=native"</code> we get:<table><thead><tr><th>Impl<th>ns / element<th>speedup<tbody><tr><td>naive<td>8.3358<td>/<tr><td>no call<td>1.2977<td>6.42<tr><td>table<td>1.1572<td>7.20<tr><td>IEE 754<td>1.1303<td>7.37<tr><td>Fixed Point<td>0.1351<td>61.7</table><h2 id=reference>Reference</h2><ul><li><a href=https://gist.github.com/zommiommy/f6a42d8c7c59826f45aa1c0cef687c1a>Code for benchmarks</a><li><a href=https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DEArgoKkl9ZATwDKjdAGFUtEywYgAzADZSjgBk8BkwAOXcAI0xiEEkADlIAB1QFQjsGFzcPbz9k1NsBIJDwliiY%2BMtMawKGIQImYgJM909fSur0uoaCIrDI6NiE827m7Lbhxt6SssGASktUE2Jkdg4AUg0AQUSTCIBqKgY9gDcuCGOxE0wFED21gCYfNYBWACETOJeAEVm9gFo1l5sAcvPc7gB2V4bTZ7WF7egEPYsEyIoj1Wi3Kigu5eL57DQAOg0gKhWzhBxIJ0umD2wSpbmuENJMPJcLRYju9yhuL2XCJewA9Ht7kSAPpYkXJADuVAgACoLgy9kwFCD7rMSdDyWtwV8tWzUOjoTq9VtjVsdvtDid7udqTdOU83h9vr8AUC1Uz9bCEUiUXt2RjPYC8YTiV5meT%2BMR6VdaUdFVdVTrI6zYYHOdy8XyNIK9lAuDinICnHsFdTfiq1RqI96IaaWenDWJjbrzdtdgcE147QyHQ8ne9Ps8fv9AcCJV6yXDfcjUc2g5OQ/iiZrp7Do7GaXTE4yU3XyRmHlm9gAlbBOACSylPAHknJsAkJRQAVTavALYF6vctKqtmPAAC9MG%2BNdG3rOtA1bBtoUtLsTkkXsk1uAdvxdEc3XHYNITrWd/UDTFsWXMMwKjSld3jLdkxw9dWV9BAmGQABrHE8QgLh7nBTMywo/9QV%2BEsS2FLxSLTAMF0zZcJRAEAqGIVAWFFEJRQiABPAhrggBjmIJIglMwFT1M02Ya1TWETUghdoPbODrWOZ4kOuFDHjQ4dR3dCciJo8C8MRNATEEAY9hMHxJFY/FRI3cjqUo3dqLM1l/MCmNj2XdjRRCsLBK8Ut%2BJxL8PV/K5Iog2jfUwVREnCpKNOIAl6CYfAjFFYD5IUCABK5XkSpq6Ii2yvEKsSHrFmS/Lx2XUL/mEkrfWIPceSgdjOO47E/j2IbK1VEw8uy0t7i8ATwVLCBepjPj1RK6TZPkxTlLUjT2vmhRdNQfTDMejqNTNNszS2NAGHMM8L2vO8HyfV930/ZzBwlb5wtQt46xzUg60JZ5Udowl7gxtGCQ43GsaJHwccx8Cwy8AmyfJMMuGeEnCfJokNHBOIqbxjQNC8ABODQGepuEww0LhueeSnSY5znufBHx6YlonOY0eI4nuNn5aZxX7kkSQpD59WaeZ4X7nuFmufZ2ifHxrnnjphnMD%2BDRGfJLwiRt8FnlZgn7cdgXYT5Z4cbiVnebth2nbhcECRJ7meckMWvYdvw6xdtnJB8aXHjl55vaT2i%2BV58EvHiHxQTV7PE99vZuYJMWfHBSRKdCvXy5ZyvJAJGW4i8cE6ZVs2ce98FK5FLw4h1uIPe5rhhazwfK75EWTe51XReeFmy7nutngJbmfCV0LJHBd2eb5rxvYSOsRW5uINAO43R5l0XxfP%2BeCUkXmuC4HxP5jseZfpl%2BdZI5x0djfZ4u9l6j1Vt7bmlcXbghxvcXmSCx7fynpIGBr84gk1Cjbd%2BB0NCi3BJgus1dKaghxvXb%2BzxD4T3ttPNuUd6bf1VoXFmhcY70I0MPAkpcvB8wbrLUe6cS5cNfl/HWYt7hcBVunIubMxFbwJH3GWe8p5FzrjrehXAeFTy5l3JW9NC7dyVto1%2BccbZTwDqrXwPgJ73DMUAgknFwEe2/uPIujx6H3DgVHbu0s4g33BIQrgPcz5/A4lgmR19uaSGtnHCestvGV2roQ9%2Bh9hZHyQarBxESvCMJofXQua9AmhVClweh%2BTL7OMLoXOuNCG53z5pU8RvhsFdyyV/L%2BXMWlKLsQ3ce2CNA3xvrkqQPCx7SOCbE/hcS4kVIidIZGb9pHDMKXTE2JtTGLMrpHaeNDOJeDccLTmYzw6whds8AOYS66BM5mvBZdNX5HxLvTLusTTlr3Lk8uscRlFs1ZjraWnMCZjNzuBdu2thnL0IRPTmOD6HgvJCKY2Ss05K2XmvchiLxHT3vrfNOONbbfKRXCbeVzP50w4uLD2Xd6FD2qUfK5Ht6a2xXlIelr8H5HyDkE1OcdiERIZRbHeo84gx15ifBB0CIkX1oi7NOsTFWWNrhy2Vzyi4IM1eAzuLN6FyvAn8uuvhQn%2BMCXEo59DYF1nbl4Npwy7Hc1iSbGRVqeFfzHkrIu78e5Szdcs4ZkhNmhK1hPNe2t/VmhHCSDg8wMQcGeLwTwHAtCkFQJwU8ZhEQKEWMsGkDxKa8AIJoWN8wmIgBtjvZ4KstY0P4TfWJGN42SF4CwCQnNSDJtTemjgvAbjcOLSm2NpA4CwCQGgFgiQ6DRHIJQCdU76AxAYHgYACACC0FUqQLAxw8ArAAGp4EwFKW8iRGCcB4HwOgtUbgQAiCW0gERggNFUue3gj7mDEFUreCI2hMA2FfaQCdbBBC3gYBu%2B9WAWCGGAOIIdW68DzRsHgY4Tk4MVT/SiVYF7ggaXjam2geAIjEGfS4LA96CDEDwG27gw6qAGGAAoA9R6T1npozIQQIgxDsHGfwQQigVDqDg7oHRBgjAgFMOYfQhGbiQHmKgRINQbgcD%2BKWeTBA/j0BQ7QEMXh/hOHqMQYAmB1PIB2CGBQTFVIGCYpgPtVQ/01AcAwZwrgWjeHyYEYIfRSgDC1kPPIaQBCjFaPkgLNQpj9BiH59oDnOgGaaK5sY%2BSrCxYEF0SYXnpi%2BcPpYeLwX3O5e6BFnzUXD7zBzUsFYEg42cETZ2%2B9Pa9gSYIMgPYy7V3rtUvmXAhBKQFq4LMItJb5haRAIsAgOwLAUFOgpBd0RQisFWM11r7W10bt4JgfARBKPoD0Lx4QohxA8dkPxtQ97hOkClMRxIw39C1aTQ1zgt4USTb2KgKgTWs0rZXWtrrEAXCTunSlA6A2htDpMqQct8QiQ6yZXHdOItHZNs4C20gbbp7cK7bwHtfaQADuGzVjg9wHtwZx6QQdWgIcoeIKkewkggA%3D%3D%3D>Code on Godbolt</a></ul></section></article></main></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>