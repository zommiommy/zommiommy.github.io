<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Webgraph from scratch: Instantaneous Codes (Draft)
    </title><link href=/corro.svg rel=icon type=image/png><link href=https://zom.wtf/fonts.css rel=stylesheet><link href=/path/to/folder/css/academicons.min.css rel=stylesheet><link href=https://zom.wtf/atom.xml rel=alternate title=zom.wtf type=application/atom+xml><link href=https://zom.wtf/theme/light.css rel=stylesheet><link href=https://zom.wtf/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><img id=title_icon src=/corro.svg><a href=https://zom.wtf>zom.wtf</a><div class=socials><a class=social href=https://twitter.com/zommiommy> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/zommiommy> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/about style=margin-left:.7em>/about</a><a href=/goodstuff style=margin-left:.7em>/good_stuff</a></nav></header><main><article><div class=title><div class=page-header>Webgraph from scratch: Instantaneous Codes (Draft)</div><div class=meta>Posted on <time>2023-09-24</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://zom.wtf/posts/webgraph-codes/#introduction>Introduction</a><li><a href=https://zom.wtf/posts/webgraph-codes/#theoretical-preliminaries>Theoretical preliminaries</a> <ul><li><a href=https://zom.wtf/posts/webgraph-codes/#information>Information</a></li><ul><li><a href=https://zom.wtf/posts/webgraph-codes/#example>Example</a><li><a href=https://zom.wtf/posts/webgraph-codes/#entropy>Entropy</a></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#instantaneous-code>Instantaneous code</a></li><ul><li><a href=https://zom.wtf/posts/webgraph-codes/#intended-distribution>Intended distribution</a></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#universal-code>Universal code</a></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#codes>Codes</a> <ul><li><a href=https://zom.wtf/posts/webgraph-codes/#fixed-length>Fixed length</a></li><ul><li><a href=https://zom.wtf/posts/webgraph-codes/#example-for-n-4>Example for N = 4</a><li><a href=https://zom.wtf/posts/webgraph-codes/#example-for-n-8>Example for N = 8</a></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#truncated-binary-encoding>Truncated Binary Encoding</a></li><ul><li><a href=https://zom.wtf/posts/webgraph-codes/#example-for-n-6>Example for N = 6</a></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#unary>Unary</a><li><a href=https://zom.wtf/posts/webgraph-codes/#elias-gamma>Elias-Gamma</a><li><a href=https://zom.wtf/posts/webgraph-codes/#elias-delta>Elias-Delta</a><li><a href=https://zom.wtf/posts/webgraph-codes/#golomb>Golomb</a><li><a href=https://zom.wtf/posts/webgraph-codes/#vbytes>VBytes</a><li><a href=https://zom.wtf/posts/webgraph-codes/#zeta>Zeta</a><li><a href=https://zom.wtf/posts/webgraph-codes/#encoding-of-negative-numbers>Encoding of negative numbers</a></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#reading-codes-fast>Reading codes fast</a> <ul><li><a href=https://zom.wtf/posts/webgraph-codes/#bitorder-big-or-little-endian>Bitorder, Big or Little endian?</a><li><a href=https://zom.wtf/posts/webgraph-codes/#buffering>Buffering?</a><li><a href=https://zom.wtf/posts/webgraph-codes/#how-big-should-we-make-the-tables>How big should we make the tables?</a><li><a href=https://zom.wtf/posts/webgraph-codes/#merged-or-separated-tables>Merged or separated tables?</a></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#benchmarks>Benchmarks</a> <ul><li><a href=https://zom.wtf/posts/webgraph-codes/#read>Read</a></li><ul><li><a href=https://zom.wtf/posts/webgraph-codes/#fixed-length-1>Fixed Length</a><li><a href=https://zom.wtf/posts/webgraph-codes/#truncated>Truncated</a><li><a href=https://zom.wtf/posts/webgraph-codes/#unary-1>Unary</a><li><a href=https://zom.wtf/posts/webgraph-codes/#gamma>Gamma</a><li><a href=https://zom.wtf/posts/webgraph-codes/#delta>Delta</a><li><a href=https://zom.wtf/posts/webgraph-codes/#zeta-3>Zeta 3</a></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#write>Write</a></li><ul><li><a href=https://zom.wtf/posts/webgraph-codes/#fixed-length-2>Fixed Length</a><li><a href=https://zom.wtf/posts/webgraph-codes/#truncated-1>Truncated</a><li><a href=https://zom.wtf/posts/webgraph-codes/#unary-2>Unary</a><li><a href=https://zom.wtf/posts/webgraph-codes/#gamma-1>Gamma</a><li><a href=https://zom.wtf/posts/webgraph-codes/#delta-1>Delta</a><li><a href=https://zom.wtf/posts/webgraph-codes/#zeta-3-1>Zeta 3</a></ul></ul><li><a href=https://zom.wtf/posts/webgraph-codes/#summary>Summary</a><li><a href=https://zom.wtf/posts/webgraph-codes/#references>References</a></ul><section class=body><h1 id=introduction>Introduction</h1><p>This post is a collection of notes I took and benchmarks I run while implementing and optimizing <a href=https://github.com/vigna/dsi-bitstream-rs>dsi-bitstream-rs</a>.<h1 id=theoretical-preliminaries>Theoretical preliminaries</h1><p>All bit sequences will be read from left to right, from top to bottom. For ease of reading I will be using the convention that <strong>all codes start from 0</strong> by adding a +1 where needed. This differs from the <strong>book definitions</strong> of the codes, but it's how you practically implement them.<h2 id=information>Information</h2><p>Information is define by the following axioms:<ul><li>The infomration \(I(p)\) of an event with probaility \(p\) is a monotone decreasing function of \(p\), i.e. \(p \le q \implies I(p) \ge I(q)\)<li>\(I(1) = 0\): The information content of a certain event is 0<li>Information is additive, i.e. the information of two independent events is the sum of the information of each event. \(I(p \cup q) = I(p) + I(q)\)</ul><p>The only function that satisfies these axioms is: \[I(p) = -\log_2 p\]<h4 id=example>Example</h4><p>A simple way to derive the information function for a discrete uniform distribution is the following:<p>Using \(n\) bits we can store \(2^n\) different values. We can invert this relationship as: a set of \(N = 2^n\) values with uniform probability has \(I(p) = \log_2 N = n\) bits of information.<p><em>We use uniform probability because we don't know anything about the data.</em><p>By definition, each value in the set has probability \(p = \frac{1}{N}\) so \(N = \frac{1}{p}\), so we can rewrite the information as: \[I(p) = -\log_2 \frac{1}{p} = -\log_2 p\]<p>which is exactly the definition of Information.<h3 id=entropy><a href=https://en.wikipedia.org/wiki/Entropy_(information_theory)>Entropy</a></h3><p><em>The entropy is the expected information.</em><p>Given a probability distribution \(p: S \to [0, 1]\) with support \(S\), the entropy of \(p\) in bits is defined as: \[\mathbb{H}(p) = -\sum_{s \in S} p(s) \log_2 p(s) = \mathbb{E}_p[-\log_2 p]\]<p>The entropy is a measure of the uncertainty of a random variable, it's maximized when all the values are equally likely and minimized when the distribution is a delta function i.e. one value has probability 1 while the other have probability 0.<p><strong>For our use cases, the entropy is the minimum number of bits needed to store a value extracted from a distribution.</strong><h2 id=instantaneous-code><a href=https://en.wikipedia.org/wiki/Prefix_code>Instantaneous code</a></h2><p>An instantaneous (binary) code (a.k.a. prefix-free code) for the set \(S\) is a function \(c : S \to {0, 1}^*\) such that, for all \(x, y \in S\), if \(c(x)\) is a prefix of \(c(y)\), then \(x = y\).<p><em>This implies that there is one unique way of decoding a given sequence</em><p><a href=https://en.wikipedia.org/wiki/Kraft%E2%80%93McMillan_inequality><strong>Kraft-McMillan</strong></a> tell us that there exists an instantaneous code with lengths \(|c(s)|\) (\(s \in S\)) if, and only if: \[\sum_{s \in S} 2^{-|c(s)|} \le 1\]<p>where \(l_s = |c(s)|\) is the length in bits of the code \(c(s)\) for value \(s \in S\).<p>A <strong>complete</strong> code is an instantaneous code where: \[\sum_{s \in S} 2^{-l_s} = 1\]<p><em>A complete code means that there are no unused codewords.</em><p>Furthermore, the expected length of \(c\) with respect to some probability distribution \(p: S \to [0, 1]\) with support \(S\) is:<p>\[\mathbb{E}_p[|c|] = \sum_{s \in S} p(s) |c(s)|\]<p>it follows that the <strong>optimal</strong> code \(c^*_p\) for a givend probability distribution \(P\) is the instantaneous code with minimum expected length.<p>If \(S\) is finite, Shannon's coding theorem tells us that the minimum expected length is the entropy of the distribution \(\mathbb{H}[p]\): \[\mathbb{E}_p[|c^*_p|] = \mathbb{H}(p)\]<p>moreover, the Huffman encoding is <strong>optimal</strong>.<h3 id=intended-distribution>Intended distribution</h3><p>Using the same equation for the expected lenght we can also compute the <strong>intended distribution</strong> i.e. the probability \(p\) that minimize the expected length \(\mathbb{E}_p[|c|]\) for a given code \(c\).<p>We can derive the intended distribution starting from: \[\mathbb{E}_p[|c^*_p|] = \mathbb{H}(p)\] by applying the respective defenitions: \[\sum_{s \ in S} p(s) |c(s)| = \sum_{s \in S} -p(s) \log_2 p(s)\] a way to make this holds is to impose that the inner terms of the sum must be equal: \[\forall s \in S \quad p(s) |c(s)| = -p(s) \log_2 p(s)\] we can factor out the common \(p(s)\) term (assuming it's not 0, in which case the equation still holds): \[\forall s \quad |c(s)| = -\log_2 p(s)\] and finally we can derive \(p(s)\): \[\forall s \quad p(s) = 2^{-|c(x)|}\]<p>Thus, the intended distribution for \(c\) is: \[p(x) = 2^{-|c(x)|}\]<p><em>Note that this is a proper distribution if and only if the code is complete, otherwise it won't sum to 1 and we would need some renormalization constant.</em><p>Therefore, to achieve best compression, <strong>we have to choose the code which intended distribution most closely match the data distribution</strong>.<h2 id=universal-code><a href=https://en.wikipedia.org/wiki/Universal_code_(data_compression)>Universal code</a></h2><h1 id=codes>Codes</h1><h3 id=fixed-length>Fixed length</h3><p>It's defined on a the set of values beween \(0\) and \(N\) (excluded) i.e. \(S = {0, 1, ..., N - 1}\), it reresents each element \(s \in S\) using \(\forall s \in S \quad |c(s)| = \lceil \log_2 N \rceil\) bits.<p>Thus, the fixed length code is optimal for uniform distributions of values in \(\left[0, N\right)\) if, and only if, \(N\) is a power of two.<h4 id=example-for-n-4>Example for N = 4</h4><table><thead><tr><th>Number<th>Code<tbody><tr><td>0<td>00<tr><td>1<td>01<tr><td>2<td>10<tr><td>3<td>11</table><p><em>Note that any other permutation of bits is also valid.</em><h4 id=example-for-n-8>Example for N = 8</h4><table><thead><tr><th>Number<th>Code<tbody><tr><td>0<td>000<tr><td>1<td>001<tr><td>2<td>010<tr><td>3<td>011<tr><td>4<td>100<tr><td>5<td>101<tr><td>6<td>110<tr><td>7<td>111</table><h3 id=truncated-binary-encoding><a href=https://en.wikipedia.org/wiki/Truncated_binary_encoding>Truncated Binary Encoding</a></h3><p>also known as minimal binary encoding, us used for uniform distributions where \(N\) is not a power of two.<p>The core idea is that we can write with \(\lfloor \log_2 N \rfloor\) bits the first \(2^{\lfloor \log_2 N \rfloor}\) values i.e. the up to the biggest power of two smaller than \(N\), and the remaining \(N - 2^{\lfloor \log_2 N \rfloor}\) values using \(\lceil \log_2 N \rceil\) bits.<h4 id=example-for-n-6>Example for N = 6</h4><table><thead><tr><th>Number<th>Code<tbody><tr><td>0<td>00<tr><td>1<td>01<tr><td>2<td>10<tr><td>3<td>11<tr><td>4<td>100<tr><td>5<td>101</table><p><strong>Note: this is not instantaneous! 2 is a prefix of 4 and 5! We will deal with this later.</strong><p>This is <strong>close to be optimal</strong>, as the expected code length is: \[\mathbb{E}[|c|] = \frac{2^{\lfloor \log_2 N \rfloor}}{N} \lfloor \log_2 N \rfloor \; + \; \left(1 - \frac{2^{\lfloor \log_2 N \rfloor}}{N} \right) \lceil \log_2 N \rceil \]<p>while the entropy is: \[\mathbb{H}[p] = \sum_{s \in S} -\frac{1}{N} \log_2 \frac{1}{N} = \log_2 N\]<p>If we define \(\alpha = \frac{2^{\lfloor \log_2 N \rfloor}}{N}\) we can notice that the expected length is the convex combination of \(\lfloor \log_2 N \rfloor\) and \(\lceil \log_2 N \rceil\):<p>\[\mathbb{E}[|c|] = \alpha \lfloor \log_2 N \rfloor \; + \; \left(1 - \alpha \right) \lceil \log_2 N \rceil \]<p>When \(N\) is a power of two this is equivalent to the fixed length and is optimal because: \[\mathbb{E}[|c|] = \lfloor \log_2 N \rfloor = \log_2 N = \lceil \log_2 N \rceil\]<p>Otherwise, by definition, a convex combination will only take cavlues between its extremes \(\lfloor \log_2 N \rfloor\) and \(\lceil \log_2 N \rceil\) so the truncated binary encoding is always smaller or equal than the fixed length.<h3 id=unary>Unary</h3><p>We can write any positive number \(s \in \mathbb{N} \) as a sequence of \(s\) zeros followed by a one, which act as a terminator.<p>\[s \to \overbrace{00...00}^\text{s} 1 = 0^s 1\]<table><thead><tr><th>Number<th>Code<tbody><tr><td>0<td>1<tr><td>1<td>01<tr><td>2<td>001<tr><td>3<td>0001<tr><td>4<td>00001<tr><td>5<td>000001<tr><td>6<td>0000001<tr><td>7<td>00000001<tr><td>8<td>000000001</table><p>This code has length \(s + 1\) therefore, its intended distribution is: \[p(x) = \left(\frac{1}{2}\right)^{s + 1}\]<p>Thus, it's optimal for the <a href=https://en.wikipedia.org/wiki/Geometric_distribution>geometric distribution</a> with \(p = \frac{1}{2}\).<p>Most modern CPUs architectures, like x86_64 and Aarch64 (Arm), have instructions to compute the leading or traling zeros in a registers.<p>x86_64 has <a href=https://www.felixcloutier.com/x86/lzcnt>LZCNT</a> and <a href=https://www.felixcloutier.com/x86/tzcnt>TZCNT</a> instructions, while Aarch64 has only <a href=https://developer.arm.com/documentation/dui0802/b/A32-and-T32-Instructions/CLZ>CLZ</a>.<p>Using these we can decode unary codes in 1 ns on average.<h3 id=elias-gamma><a href=https://en.wikipedia.org/wiki/Elias_gamma_coding#Further_reading>Elias-Gamma</a></h3><p>Unary + Fixed Length<table><thead><tr><th>Number<th>Code<tbody><tr><td>0<td>1<tr><td>1<td>01 0<tr><td>2<td>01 1<tr><td>3<td>001 00<tr><td>4<td>001 01<tr><td>5<td>001 10<tr><td>6<td>001 11<tr><td>7<td>0001 000<tr><td>8<td>0001 001</table><h3 id=elias-delta><a href=https://en.wikipedia.org/wiki/Elias_delta_coding>Elias-Delta</a></h3><p>What happens if we write the unary part of gamma, using another gamma?<p><a href=https://xkcd.com/1270/><img alt src=https://imgs.xkcd.com/comics/functional.png></a><table><thead><tr><th>Number<th>Code<tbody><tr><td>0<td>1<tr><td>1<td>01 0 0<tr><td>2<td>01 1 1<tr><td>3<td>01 10 0<tr><td>4<td>01 10 1<tr><td>5<td>01 11 0<tr><td>6<td>01 11 1<tr><td>7<td>0001 00 000<tr><td>8<td>0001 00 001</table><h3 id=golomb>Golomb</h3><p>for a given b, write \(\lfloor \frac{s}{b} \rfloor \) in unary and \(s \mod b\) using truncated encoding.<p>The length is \(|c(s)| = \left \lfloor \frac{s}{b} \right \rfloor + \lceil \log_2 b \rceil\) thus, its<p>For a Geometric distribution of ratio \(p\) we can compute the \(b\) so that the Golomb code is optimal: \[b = \left \lceil \frac{\log_2 (2 - p)}{-\log(1 - p)} \right \rceil\]<h3 id=vbytes>VBytes</h3><p>This code, in its variation LEB128 is really common as it's present in both DWARF format and Webassembly binary format.<p>Byte-aligned<p>write 7 bits and use the highest to set 0 if continue 1 if stop.<p>The faster variation is to have all the 0s at the start, so basically writing the number of bytes - 1 in unary at the start.<p>LEB128 is not complete and redundant as it has infinite encodings for each number as we can just add 0 padding on the top. Moreover, if a value uses 2 bytes we know that it must be bigger than 127, so we can subtract it to fit more values, and this can be done recursively.<h3 id=zeta><a href=https://vigna.di.unimi.it/ftp/papers/Codes.pdf>Zeta</a></h3><p>Unary + Truncated Encoding<pre class=language-python data-lang=python style=background:#0f1419;color:#bfbab0><code class=language-python data-lang=python><span style=color:#ff7733>from </span><span>math </span><span style=color:#ff7733>import </span><span>floor</span><span style=color:#bfbab0cc>, </span><span>ceil</span><span style=color:#bfbab0cc>, </span><span>log2
</span><span>
</span><span style=color:#ff7733>def </span><span style=color:#ffb454>write_zeta</span><span>(</span><span style=color:#f29718>value</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>k</span><span>):
</span><span>    value </span><span style=color:#f29668>+= </span><span style=color:#f29718>1
</span><span>    h </span><span style=color:#f29668>= </span><span style=font-style:italic;color:#39bae6>int</span><span>(</span><span style=color:#ffb454>floor</span><span>(</span><span style=color:#ffb454>log2</span><span>(value)) </span><span style=color:#f29668>/ </span><span>k)
</span><span>    u </span><span style=color:#f29668>= </span><span style=color:#f29718>2</span><span style=color:#f29668>**</span><span>((h </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span>) </span><span style=color:#f29668>* </span><span>k)
</span><span>    l </span><span style=color:#f29668>= </span><span style=color:#f29718>2</span><span style=color:#f29668>**</span><span>(h </span><span style=color:#f29668>* </span><span>k)
</span><span>
</span><span>    data  </span><span style=color:#f29668>= </span><span style=color:#ffb454>write_unary</span><span>(h)
</span><span>    data </span><span style=color:#f29668>+= </span><span style=color:#ffb454>write_minimal_binary</span><span>(value </span><span style=color:#f29668>- </span><span>l</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>max</span><span style=color:#f29668>=</span><span>u </span><span style=color:#f29668>- </span><span>l)
</span><span>    </span><span style=color:#ff7733>return </span><span>data
</span><span>
</span><span style=color:#ff7733>def </span><span style=color:#ffb454>len_zeta</span><span>(</span><span style=color:#f29718>value</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>k</span><span>):
</span><span>    value </span><span style=color:#f29668>+= </span><span style=color:#f29718>1
</span><span>    h </span><span style=color:#f29668>= </span><span style=font-style:italic;color:#39bae6>int</span><span>(</span><span style=color:#ffb454>floor</span><span>(</span><span style=color:#ffb454>log2</span><span>(value)) </span><span style=color:#f29668>/ </span><span>k)
</span><span>    u </span><span style=color:#f29668>= </span><span style=color:#f29718>2</span><span style=color:#f29668>**</span><span>((h </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span>) </span><span style=color:#f29668>* </span><span>k)
</span><span>    l </span><span style=color:#f29668>= </span><span style=color:#f29718>2</span><span style=color:#f29668>**</span><span>(h </span><span style=color:#f29668>* </span><span>k)
</span><span>    </span><span style=color:#ff7733>return </span><span style=color:#ffb454>len_unary</span><span>(h) </span><span style=color:#f29668>+ </span><span style=color:#ffb454>len_minimal_binary</span><span>(value </span><span style=color:#f29668>- </span><span>l</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>max</span><span style=color:#f29668>=</span><span>u </span><span style=color:#f29668>- </span><span>l)
</span><span>
</span><span>
</span><span style=color:#ff7733>def </span><span style=color:#ffb454>read_zeta</span><span>(</span><span style=color:#f29718>data</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>k</span><span>):
</span><span>    h, data </span><span style=color:#f29668>= </span><span style=color:#ffb454>read_unary</span><span>(data)
</span><span>    u </span><span style=color:#f29668>= </span><span style=color:#f29718>2</span><span style=color:#f29668>**</span><span>((h </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span>) </span><span style=color:#f29668>* </span><span>k)
</span><span>    l </span><span style=color:#f29668>= </span><span style=color:#f29718>2</span><span style=color:#f29668>**</span><span>(h </span><span style=color:#f29668>* </span><span>k)
</span><span>    r, data </span><span style=color:#f29668>= </span><span style=color:#ffb454>read_minimal_binary</span><span>(data</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>max</span><span style=color:#f29668>=</span><span>u </span><span style=color:#f29668>- </span><span>l)
</span><span>    </span><span style=color:#ff7733>return </span><span>l </span><span style=color:#f29668>+ </span><span>r </span><span style=color:#f29668>- </span><span style=color:#f29718>1</span><span>, data
</span></code></pre><table><thead><tr><th>Number<th>Zeta1<th>Zeta2<th>Zeta3<th>Zeta4<tbody><tr><td>0<td>1<td>1 0<td>1 00<td>1 000<tr><td>1<td>01 0<td>1 10<td>1 010<td>1 0010<tr><td>2<td>01 1<td>1 11<td>1 011<td>1 0011<tr><td>3<td>001 00<td>01 000<td>1 100<td>1 0100<tr><td>4<td>001 01<td>01 001<td>1 101<td>1 0101<tr><td>5<td>001 10<td>01 010<td>1 110<td>1 0110<tr><td>6<td>001 11<td>01 011<td>1 111<td>1 0111<tr><td>7<td>0001 000<td>01 1000<td>01 00000<td>1 1000</table><p><em>Note that Zeta1 == Gamma</em><h2 id=encoding-of-negative-numbers>Encoding of negative numbers</h2><p>All the discussed codes are defined over some subset of \(\mathbb{N}\), to encode over \(\mathbb{Z}\), we have to define a bijection \(\phi: \mathbb{Z} \to \mathbb{N}\).<p>If we can assume that the values form some kind of bell shape centered around zero, as we often do, it's best to map values with small absolute value to small integers, so it's natural to use the following bijection:<p>\[\phi(x) = \left\{\begin{matrix} 2 x & \text{if } x \ge 0\\- 2 x - 1 & \text{otherwise}\end{matrix}\right.\] which has inverse: \[\phi^{-1}(x) = \left\{\begin{matrix} x / 2 & \text{if } x = 0 \mod 2\\ -(x + 1) / 2 & \text{otherwise}\end{matrix}\right.\]<table><thead><tr><th>\(x \in \mathbb{N}\)<th>\(\phi^{-1}(x) \in \mathbb{Z}\)<tbody><tr><td>0<td>0<tr><td>1<td>-1<tr><td>2<td>1<tr><td>3<td>-2<tr><td>4<td>2<tr><td>5<td>-3<tr><td>6<td>3</table><p>this can be efficiently implemented as:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>]
</span><span style=color:#ff7733>pub const fn </span><span style=color:#ffb454>int2nat</span><span>(</span><span style=color:#f29718>x</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>i64</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#ff7733>u64 </span><span>{
</span><span>    (x </span><span style=color:#f29668><< </span><span style=color:#f29718>1 </span><span style=color:#f29668>^ </span><span>(x </span><span style=color:#f29668>>> </span><span style=color:#f29718>63</span><span>)) </span><span style=color:#f29668>as </span><span style=color:#ff7733>u64
</span><span>}
</span><span>
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>]
</span><span style=color:#ff7733>pub const fn </span><span style=color:#ffb454>nat2int</span><span>(</span><span style=color:#f29718>x</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>u64</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#ff7733>i64 </span><span>{
</span><span>    ((x </span><span style=color:#f29668>>> </span><span style=color:#f29718>1</span><span>) </span><span style=color:#f29668>^ !</span><span>((x </span><span style=color:#f29668>& </span><span style=color:#f29718>1</span><span>)</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_sub</span><span>(</span><span style=color:#f29718>1</span><span>))) </span><span style=color:#f29668>as </span><span style=color:#ff7733>i64
</span><span>}
</span></code></pre><p>which in x86_64 assembly should look like:<pre class=language-asm data-lang=asm style=background:#0f1419;color:#bfbab0><code class=language-asm data-lang=asm><span style=color:#ffb454>int2n</span><span style=color:#f07178>at</span><span style=color:#ffb454>:
</span><span style=color:#ffb454>        </span><span style=color:#ff7733>sar     </span><span style=color:#f29718>rdi</span><span>, </span><span style=color:#f29718>63
</span><span style=color:#ffb454>        </span><span style=color:#ff7733>xor     </span><span style=color:#f29718>rax</span><span>, </span><span style=color:#f29718>rdi
</span><span>
</span><span style=color:#ffb454>nat2int:
</span><span style=color:#ffb454>        </span><span style=color:#ff7733>and     </span><span style=color:#f29718>edi</span><span>, </span><span style=color:#f29718>1
</span><span style=color:#ffb454>        </span><span style=color:#ff7733>shr     </span><span style=color:#f29718>rax
</span><span style=color:#ffb454>        </span><span style=color:#ff7733>neg     </span><span style=color:#f29718>rdi
</span><span style=color:#ffb454>        </span><span style=color:#ff7733>xor     </span><span style=color:#f29718>rax</span><span>, </span><span style=color:#f29718>rdi
</span></code></pre><h1 id=reading-codes-fast>Reading codes fast</h1><h3 id=bitorder-big-or-little-endian>Bitorder, Big or Little endian?</h3><p>We have to choose if for us the bit 0 of a byte is the Most Significant Bit (MSB) or the Least Significant Bit (LSB). Both have different pro and cons for performance, but the main difference is that MSB is the default in Java.<h3 id=buffering>Buffering?</h3><p>In this section, we'll see the core ideas we had while implementing our rust crate for reading and wring bitstreams: <a href=https://github.com/vigna/dsi-bitstream-rs><code>dsi-bitstream-rs</code></a>.<p>By definition, most codes we will read will take just a few bits so the idea is to have a buffer of 64 bits and read from it. This avoids having a memory access for each read, which is a common bottleneck.<p>If we don't allow reads over 32-bits, we can use a 64-bits buffer, so we know that there will always be space for the next read, and operations on 64-bits words are fast on most modern CPUS.<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>pub struct </span><span style=color:#59c2ff>Reader</span><span><</span><span style=color:#ff7733>'a</span><span>> {
</span><span>    </span><span style=font-style:italic;color:#5c6773>/// The buffer of bits we will read from
</span><span>    buffer</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>u64</span><span>,
</span><span>    </span><span style=font-style:italic;color:#5c6773>/// how many bits are valid in the buffer
</span><span>    valid_bits</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>usize</span><span>,
</span><span>    </span><span style=font-style:italic;color:#5c6773>/// The data to read from
</span><span>    data</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#ff7733>'a</span><span> [</span><span style=color:#ff7733>u32</span><span>]
</span><span>}
</span></code></pre><p>Now we have two possible convention, we can either read the bits in a byte from the Most Significant Bit to the Least Significant Bit or viceversa.<p>MSB to LSB implies that we will have to read the data using BigEndian order of bytes, while LSB to MSB implies LittleEndian order.<p>It's not clear at priori which is the best choice, but we can easily implement both and benchmark them. In the following examples we will only discuss the Big Endian (MSB to LSB) version as is the default in the Java implementation of webgraph.<p>Now let's implement a method for how to read the next <code>bits</code> bits from the buffer:<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>impl</span><span><</span><span style=color:#ff7733>'a</span><span>> </span><span style=color:#59c2ff>Reader</span><span><</span><span style=color:#ff7733>'a</span><span>> {
</span><span>    </span><span style=color:#ff7733>pub fn </span><span style=color:#ffb454>read_bits</span><span>(</span><span style=color:#f29668>&</span><span style=color:#ff7733>mut </span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>bits</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>usize</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#ff7733>u32 </span><span>{
</span><span>        </span><span style=color:#f07178>debug_assert!</span><span>(bits </span><span style=color:#f29668><= </span><span style=color:#f29718>32</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#5c6773>// if there aren't enough bits
</span><span>        </span><span style=color:#ff7733>if </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits </span><span style=color:#f29668><</span><span> bits {
</span><span>            </span><span style=font-style:italic;color:#5c6773>// read a new word and add it tot he buffer
</span><span>            </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>buffer </span><span style=color:#f29668>|= </span><span>(</span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>data[</span><span style=color:#f29718>0</span><span>] </span><span style=color:#f29668>as </span><span style=color:#ff7733>u64</span><span>) </span><span style=color:#f29668><< </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits </span><span style=color:#f29668>+= </span><span style=color:#f29718>32</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>data </span><span style=color:#f29668>= &</span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>data[</span><span style=color:#f29718>1</span><span style=color:#f29668>..</span><span>]</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>        </span><span style=font-style:italic;color:#5c6773>// extract the lowest bits
</span><span>        </span><span style=color:#ff7733>let</span><span> res </span><span style=color:#f29668>= </span><span>(</span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>buffer </span><span style=color:#f29668>as </span><span style=color:#ff7733>u32</span><span>) </span><span style=color:#f29668>& </span><span>((</span><span style=color:#f29718>1 </span><span style=color:#f29668><<</span><span> bits </span><span style=color:#f29668>as </span><span style=color:#ff7733>u32</span><span>) </span><span style=color:#f29668>- </span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>buffer </span><span style=color:#f29668>>>= </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits </span><span style=color:#f29668>-=</span><span> bits</span><span style=color:#bfbab0cc>;
</span><span>        res
</span><span>    }
</span><span>}
</span></code></pre><p>And now, how to read unary codes we can use rust's <code>leaing_zeros</code> which uses the <code>lzcnt</code> instruction on x86_64 and <code>clz</code> on Aarch64, if the feature is enables. Otherwise Rust will generate the broadword code for it.<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>impl</span><span><</span><span style=color:#ff7733>'a</span><span>> </span><span style=color:#59c2ff>Reader</span><span><</span><span style=color:#ff7733>'a</span><span>> {
</span><span>    </span><span style=color:#ff7733>pub fn </span><span style=color:#ffb454>read_unary</span><span>(</span><span style=color:#f29668>&</span><span style=color:#ff7733>mut </span><span style=color:#f29718>self</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#ff7733>usize</span><span>{
</span><span>        </span><span style=color:#ff7733>let</span><span> zeros </span><span style=color:#f29668>= </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>buffer</span><span style=color:#f29668>.</span><span style=color:#f07178>leading_zeros</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#5c6773>// the unary code fits inside the valid bits
</span><span>        </span><span style=color:#ff7733>if</span><span> zeros </span><span style=color:#f29668><= </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits {
</span><span>            </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>buffer </span><span style=color:#f29668><<=</span><span> zeros </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits </span><span style=color:#f29668>-=</span><span> zeros </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#ff7733>return</span><span> zeros </span><span style=color:#f29668>+ </span><span style=color:#f29718>1
</span><span>        }
</span><span>        </span><span style=color:#ff7733>let mut</span><span> res </span><span style=color:#f29668>=</span><span> zeros</span><span style=color:#bfbab0cc>;
</span><span>        
</span><span>        </span><span style=font-style:italic;color:#5c6773>// otherwise we have to read another word
</span><span>        </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>buffer </span><span style=color:#f29668>= </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>data[</span><span style=color:#f29718>0</span><span>] </span><span style=color:#f29668><< </span><span style=color:#f29718>32</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits </span><span style=color:#f29668>+= </span><span style=color:#f29718>32</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>data </span><span style=color:#f29668>= &</span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>data[</span><span style=color:#f29718>1</span><span style=color:#f29668>..</span><span>]</span><span style=color:#bfbab0cc>;
</span><span>
</span><span>        </span><span style=color:#ff7733>let</span><span> zeros </span><span style=color:#f29668>= </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>buffer</span><span style=color:#f29668>.</span><span style=color:#f07178>leading_zeros</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#5c6773>// our assumption is that all unary and bits are under 32 bits
</span><span>        </span><span style=font-style:italic;color:#5c6773>// this is for simplicity, but it can be generalized
</span><span>        </span><span style=color:#f07178>debug_assert!</span><span>(zeros </span><span style=color:#f29668>< </span><span style=color:#f29718>32</span><span>)</span><span style=color:#bfbab0cc>; 
</span><span>        res </span><span style=color:#f29668>+=</span><span> zeros</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>valid_bits </span><span style=color:#f29668>-=</span><span> zeros </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=font-style:italic;color:#39bae6>self</span><span style=color:#f29668>.</span><span>buffer </span><span style=color:#f29668><<=</span><span> zeros </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>        res
</span><span>    } 
</span><span>}
</span></code></pre><h3 id=how-big-should-we-make-the-tables>How big should we make the tables?</h3><p>What's the optimal size for tables?<h3 id=merged-or-separated-tables>Merged or separated tables?</h3><p>Merged have better cache locality and a single memory access, but they are bigger than separated ones, due to padding.<p><strong>The answer to all these questions is to benchmark!</strong><h1 id=benchmarks>Benchmarks</h1><p>These benchmarks were run on a <a href=https://en.wikichip.org/wiki/intel/core_i7/i7-8750h><strong>Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz</strong></a>, the csv with the raw data can be found <a href=/codes/read.csv>here for reads</a> and <a href=/codes/write.csv>here for writes</a>.<p>To run these benchmarks on your own machine you can use the following command:<pre class=language-bash data-lang=bash style=background:#0f1419;color:#bfbab0><code class=language-bash data-lang=bash><span style=font-style:italic;color:#5c6773># Clone the repo
</span><span style=color:#ffb454>git</span><span> clone https://github.com/vigna/dsi-bitstream-rs.git
</span><span style=color:#f07178>cd</span><span> dsi-bitstream-rs
</span><span style=font-style:italic;color:#5c6773># Run the read benchmarks
</span><span style=color:#ffb454>python3</span><span> ./python/bench_code_tables_read.py </span><span style=color:#f29668>></span><span> read.csv
</span><span style=font-style:italic;color:#5c6773># Make the plots
</span><span style=color:#ffb454>cat</span><span> read.csv </span><span style=color:#f29668>| </span><span style=color:#ffb454>python3</span><span> ./python/plot_code_tables_read.py
</span><span style=font-style:italic;color:#5c6773># Run the write benchmarks
</span><span style=color:#ffb454>python3</span><span> ./python/bench_code_tables_write.py </span><span style=color:#f29668>></span><span> write.csv
</span><span style=font-style:italic;color:#5c6773># Make the plots
</span><span style=color:#ffb454>cat</span><span> write.csv </span><span style=color:#f29668>| </span><span style=color:#ffb454>python3</span><span> ./python/plot_code_tables_write.py
</span></code></pre><h2 id=read>Read</h2><h4 id=fixed-length-1>Fixed Length</h4><p>TODO!:<h4 id=truncated>Truncated</h4><p>TODO!:<h4 id=unary-1>Unary</h4><p><img alt src=/codes/unary_read_tables.svg><h4 id=gamma>Gamma</h4><p><img alt src=/codes/gamma_read_tables.svg><h4 id=delta>Delta</h4><p>Since Delta has a gamma code inside, we can choose if the gamma code is read using a table or not.<p>Without gamma table: <img alt src=/codes/delta_read_tables.svg> With gamma table (8 bits): <img alt src=/codes/delta_gamma_read_tables.svg><h4 id=zeta-3>Zeta 3</h4><p><img alt src=/codes/zeta3_read_tables.svg><h2 id=write>Write</h2><h4 id=fixed-length-2>Fixed Length</h4><p>TODO!:<h4 id=truncated-1>Truncated</h4><p>TODO!:<h4 id=unary-2>Unary</h4><p><img alt src=/codes/unary_write_tables.svg><h4 id=gamma-1>Gamma</h4><p><img alt src=/codes/gamma_write_tables.svg><h4 id=delta-1>Delta</h4><p>Since Delta has a gamma code inside, we can choose if the gamma code is write using a table or not.<p>Without gamma table: <img alt src=/codes/delta_write_tables.svg> With gamma table (TODO bits): <img alt src=/codes/delta_gamma_write_tables.svg><h4 id=zeta-3-1>Zeta 3</h4><p><img alt src=/codes/zeta3_write_tables.svg><h1 id=summary>Summary</h1><table><thead><tr><th>Code<th>Distribution<th>Avg. Read (ns)<th>Avg. Write (ns)<tbody><tr><td>Fixed Length<td>\(\frac{1}{|S|}\), Uniform were \(|S|\) is a power of two<td>TODO<td>TODO<tr><td>Truncated<td>\(\frac{1}{|S|}\), Uniform<td>TODO<td>TODO<tr><td>Unary<td>\((1 / 2)^s\), Geometric with p = \(\frac{1}{2}\)<td>1.58<td>1.49<tr><td>Gamma<td>Universal, \(\approx \frac{1}{2s^2}\), zipfian with \(\alpha = 2\)<td>1.90<td>1.59<tr><td>Delta<td>Universal, \(\approx \frac{1}{2s(\log (s + 1))^2}\), zipfian with \(\alpha \approx 1\)<td>3.11<td>2.77<tr><td>Zeta (k = 3)<td>\(\approx \frac{1}{x^{1 + 1 / k}}\), close to an arbitrary zipfian<td>5.20<td>3.76</table><p>From all the benchmarks we learn that for <strong>reads</strong>:<ul><li><strong>Unary</strong>: no table is needed.<li><strong>Gamma</strong>: with or without table is pretty close, so we can not use a table to leave more cache space for the other codes.<li><strong>Delta</strong>: It's fastest with no table, but with gamma table enabled.<li><strong>Zeta</strong>: It's fastest with a 12-bit table.</ul><p><strong>Gamma</strong> is fast and universal, so it's a good default choice.<p><strong>Writes</strong> are generally faster than <strong>Reads</strong>, and all codes gets fasters with bigger tables.<p>Specifically, for <strong>Writes</strong> is optimal to use:<ul><li><strong>Unary</strong>: 3 bits table.<li><strong>Gamma</strong>: 6 bits table.<li><strong>Delta</strong>: 13 bits table, with gamma tables.<li><strong>Zeta3</strong>: 15 bits table.</ul><p><strong>LittleEndian</strong> is slightly faster than <strong>BigEndian</strong> when <strong>reading</strong> with no tables, but with tables they are close due to the better cache locality of Big Endian tables. <strong>Writes</strong> otherwise, are faster with <strong>BigEndian</strong>.<p><strong>Separated</strong> tables are faster than <strong>Combined</strong> tables when the table is bigger than the L1 cache (this cpu has 32KiB \(\approx 2^{15}\) L1D per core), and basically the same otherwise.<p><em>Benchmarks are useful :)</em><h1 id=references>References</h1><ul><li><a href=https://github.com/vigna/dsi-bitstream-rs>https://github.com/vigna/dsi-bitstream-rs</a><li><a href=https://vigna.di.unimi.it/ftp/papers/Codes.pdf>https://vigna.di.unimi.it/ftp/papers/Codes.pdf</a><li><a href=https://boldi.di.unimi.it/Corsi/AlgorithmsForLargeGraphs/lesson1.pdf>https://boldi.di.unimi.it/Corsi/AlgorithmsForLargeGraphs/lesson1.pdf</a></ul></section></article></main></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>