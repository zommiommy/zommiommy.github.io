<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Storing a set of integers, Elias-Fano, and Graphs (Pt.1)
    </title><link href=/corro.svg rel=icon type=image/png><link href=https://zom.wtf/fonts.css rel=stylesheet><link href=/path/to/folder/css/academicons.min.css rel=stylesheet><link href=https://zom.wtf/atom.xml rel=alternate title=zom.wtf type=application/atom+xml><link href=https://zom.wtf/theme/light.css rel=stylesheet><link href=https://zom.wtf/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><img id=title_icon src=/corro.svg><a href=https://zom.wtf>zom.wtf</a><div class=socials><a class=social href=https://twitter.com/zommiommy> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/zommiommy> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/about style=margin-left:.7em>/about</a><a href=/goodstuff style=margin-left:.7em>/good_stuff</a></nav></header><main><article><div class=title><div class=page-header>Storing a set of integers, Elias-Fano, and Graphs (Pt.1)</div><div class=meta>Posted on <time>2022-11-10</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://zom.wtf/posts/eliasfano-pt1/#introduction>Introduction</a><li><a href=https://zom.wtf/posts/eliasfano-pt1/#theoretical-lowerbound>Theoretical Lowerbound</a><li><a href=https://zom.wtf/posts/eliasfano-pt1/#elias-fano>Elias-Fano</a> <ul><li><a href=https://zom.wtf/posts/eliasfano-pt1/#lower-bits-l>Lower Bits \(L\)</a><li><a href=https://zom.wtf/posts/eliasfano-pt1/#high-bits-h>High bits \(H\)</a><li><a href=https://zom.wtf/posts/eliasfano-pt1/#optimal-threshold-l>Optimal Threshold \(l\)</a><li><a href=https://zom.wtf/posts/eliasfano-pt1/#elias-fano-memory-usage-mathcal-ef-u-n>Elias-Fano memory usage \(\mathcal{EF}(u, n)\)</a><li><a href=https://zom.wtf/posts/eliasfano-pt1/#concurrent-reads-and-writes>Concurrent reads and writes</a></ul><li><a href=https://zom.wtf/posts/eliasfano-pt1/#references>References</a></ul><section class=body><h2 id=introduction>Introduction</h2><p>In this post we will tackle the problem of indexing a set \(X\) of positive integers that takes values in the range \(0 \le x \le u \quad \forall x \in X\) for a given upper-bound \(u\).<p>Our goal is to store this set in as little memory as possible and to have the following two operations in \(\mathcal{O}(1)\) (constant time):<ul><li>\(\text{rank}(X, v)\) returns the number of values in \(X\) that are strictly smaller than \(v\)<li>\(\text{select}(X, i)\) returns the \(i\)-th smallest value in \(X\)</ul><p>These two operations were introduced by <a href=https://web.archive.org/web/20160312010342/https://www.computer.org/csdl/proceedings/focs/1989/1982/00/063533.pdf>Jacobson in its influential paper</a> and were originally meant to simulate a tree, but they are generally usefull and fundamental operations for all succint data-structures.<p>To be more precise, we are searching for a <strong>succint data-structure</strong>, which is a representation that allows for fast <strong>rank</strong> and <strong>select</strong> and uses \(Z + o(Z)\) bits, where \(Z\) is the information-theoretical minimum space required.<h2 id=theoretical-lowerbound>Theoretical Lowerbound</h2><p>Before thinking about the data-structure we should have to compute the theoretical minimum number of bits \(Z\) required for our task using Shannon's entropy. Shannon's tells us that the entropy \(\mathbb{H}(X_S)\), measured in bits, of a random variable \(X_S\) that has support over a set \(S\) of element \(s \in S\) with probability \(P(s)\) is: \[\mathbb{H}(X_S) = \left \lceil -\sum_{s \in S} P(s) \log_2 P(s) \right \rceil \quad \text{bits}\]<p>We cannot make any assumption over the probability of each possible set we want to store and index. Thus, we have to consider the most entropic discrete distribution, i.e. an uniform distribution \(P(s) = \frac{1}{|S|} \quad \forall s \in S\). In this particular condition, the entropy of our random variable greatly simplify:<p>\[\begin{aligned} \mathbb{H}(X_S) &= \left \lceil -\sum_{s \in S} \frac{1}{|S|} \log_2 \frac{1}{|S|} \right \rceil \\ &=\left \lceil - \log_2 \frac{1}{|S|} \right \rceil\\<br> &= \left \lceil \log_2 |S| \right \rceil \text{bits} \end{aligned}\]<p>So the next step is to figure out what's the cardinality of our set \(|S|\), which is the set of all the possible sets of integers with \(|X|\) values between \(0\) and \(u\). <strong>If we don't allows for duplicates</strong>, this can be thought as how many ways we can extract \(n = |X|\) values for a set of \(u\) elements. This is a classical combinatorial problem so we know that \(|S| = \binom{u}{n}\). So finally we obtain that:<p>\[Z = \mathbb{H}(X_S) = \left \lceil \log_2 \binom{u}{n} \right \rceil \quad \text{bits}\]<p>To be able to better understand how many bits these are, we can asymptotically simplify it using the binomal coefficient definition and Stirling's approximation to all the factorials:<p>\[\log_2 \binom{u}{n} = \log_2 \frac{u!}{n!(u-n)!}\qquad\qquad n! \sim_{n \to \infty} \sqrt{2\pi n } \left (\frac{n}{e} \right)^n \]<p>\[\log_2 \binom{u}{n} \sim_{u, n \to \infty} \log_2 \frac{\sqrt{2 \pi u} \left ( \frac{u}{e} \right)^u}{\sqrt{2 \pi n} \left ( \frac{n}{e} \right)^n \sqrt{2 \pi (u - n)} \left ( \frac{(u - n)}{e} \right)^{(u - n)}}\]<p>Now hold your breath and let's do some arithmetic simplifications:<p>\[\begin{aligned} \log_2 \binom{u}{n} &\sim_{u, n \to \infty} \log_2 \frac{\sqrt{u} u^u e^{-u}}{\sqrt{n} n^n e^{-n} \sqrt{2 \pi} \sqrt{u - n} (u - n)^{(u - n)} e^{n - u}} \\ &\sim_{u, n \to \infty} \log_2 \frac{\sqrt{u} u^u}{\sqrt{2 \pi} \sqrt{n} n^n \sqrt{u - n} (u - n)^{(u - n)}} \\ &\sim_{u, n \to \infty} \log_2 \frac{1}{\sqrt{2 \pi}} \sqrt{\frac{u}{n (u - n)}} \frac{u^u}{n^n (u - n)^{(u - n)}} \\ &\sim_{u, n \to \infty} \log_2 \frac{1}{\sqrt{2 \pi}} + \log_2 \sqrt{\frac{u}{n (u - n)}} + \log_2 \frac{u^u}{n^n (u - n)^{(u - n)}} \\ &\sim_{u, n \to \infty} -\frac{1}{2} \log_2 2 \pi + \frac{1}{2}\log_2 \frac{u}{n (u - n)} + \log_2 \frac{u^u}{n^n (u - n)^{(u - n)}} \\ &\sim_{u, n \to \infty} -\frac{1}{2} \log_2 2 \pi + \frac{1}{2}\log_2 u - \frac{1}{2}\log_2 (u - n) + u \log_2 u - n \log_2 n - (u - n) \log_2 (u - n) \\ &\sim_{u, n \to \infty} u \log_2 u - n \log_2 n - (u - n) \log_2 (u - n) -\frac{1}{2} \log_2 2 \pi + \frac{1}{2}\log_2 u - \frac{1}{2}\log_2 (u - n) \\ &\qquad+ (u -n) \log_2 u - (u - n) \log_2 u \\ &\sim_{u, n \to \infty} n \log_2 \frac{u}{n} + (u - n) \log_2 \frac{u}{u - n} + \frac{1}{2} \log_2 \frac{u}{(u - n)} - \log_2 \sqrt{2 \pi} \\ \end{aligned}\]<p>Now we can exploit the simmetry and only consider the case where \(n \le \frac{u}{2}\) without any loss of generality (we can always choose to store the smallest set between \(X\) and \([0, u] \setminus X \)):<p>\[\begin{aligned} &\sim_{u, n \to \infty} n \log_2 \frac{u}{n} + (u - n) \log_2 \frac{u}{u - n} + \mathcal{O}(\log u) \\ &\sim_{u, n \to \infty} n \log_2 \frac{u}{n} + \mathcal{O}(n) \end{aligned}\]<p>Therefore, we finally obtain that:<p>\[Z \sim_{u, n \to \infty} n \log_2 \frac{u}{n} + \mathcal{O}(n)\] <em>It can be trivially proved that in this context the ceil does not change the complexity</em><p>Noticing that \(u / n\) is the average gap between two successive values in the set, we can interpret this result as:<p><strong>The best way we have to save a set of unsorted integers is to encode the gaps between the values in the set.</strong><hr><h2 id=elias-fano>Elias-Fano</h2><p>There's a data-strcutrue introduced by Sebastiano Vigna called <a href=https://arxiv.org/pdf/1206.4300.pdf>EliasFano Index</a> which, based on the work of Perer Elias and Rober Fano on instantaneous code, allows us to solve our task using memory which is <strong>close</strong> to the lower-bound we found and it's called Elias-Fano.<p>This encoding sort the values and split, using an optimal threshold \(l\), their binary encoding (\(\lceil \log_2 u \rceil\) bits) into lower bits (\(l\) bits) and higher (\(\lceil \log_2 u \rceil - l\) bits) bits. The low bits are stored contiguosly, while the gap between the high-bits are stored using the <a href=https://en.wikipedia.org/wiki/Unary_coding><strong>inverted unary encoding</strong></a>.<p><img alt src=/elias_fano.png><h3 id=lower-bits-l>Lower Bits \(L\)</h3><p>The lower \(l\) bits of each value are just concatenated. For each element \(x_i\) we are going to store the lower \(l\) bits.<p>Since by definition, each element takes \(l\) bits, for a value \(x_i \qquad \forall 0 \le i < n\) the total memory needed to store the lower bits is: \[L = n l + \mathcal{O}(1) \text{bits}\]<p>We store these bits as contiguous array, we can efficently read and write the low bits.<h3 id=high-bits-h>High bits \(H\)</h3><p>The inverted unary encoding \(\mathcal{U}: \mathbb{N} \to 0^*1\) for a given integer \(x\) is as a sequence of \(x\) <strong>0s</strong> and then a delimiter <strong>1</strong>, it follows that \(|\mathcal{U}(x)| = x + 1\):<table><thead><tr><th>\(x\)<th>\(\mathcal{U}(x) = 0^x1 \)<tbody><tr><td>0<td>1<tr><td>1<td>01<tr><td>2<td>001<tr><td>3<td>0001<tr><td>4<td>00001</table><p>The higher-bits of each value \(x_i \quad \forall 0 \le i < n\) are \(h_i = \left\lfloor \frac{x_i}{2^l} \right \rfloor \), where \(h_0 = 0\), we can compute the number of bits used by the high-bits \(H\) as: \[\begin{aligned} H &= \sum_{0 \le i < n} |\mathcal{U}(h_{i + 1} - h_{i})| + \mathcal{O}(1)\\ &= \sum_{0 \le i < n} h_{i + 1} - h_{i} + 1 + \mathcal{O}(1)\\ &= \sum_{0 \le i < n} h_{i + 1} - h_{i} + \sum_{0 \le i < n } 1 + \mathcal{O}(1)\\ &= n + \sum_{0 \le i < n} h_{i + 1} - h_{i}+ \mathcal{O}(1)\\ \end{aligned}\]<p>Since it's a telescopic series, we know that:<p>\[\sum_{0 \le i < n} h_{i + 1} - h_{i} = h_n - h_0 = h_n - 0 = h_n\]<p>By recalling that \(0 \le x_n \le u\) we can finally obtainin an upperbound:<p>\[H = n + \left\lfloor \frac{x_n}{2^l} \right \rfloor + \mathcal{O}(1) \le n + \left\lfloor \frac{u}{2^l} \right \rfloor + \mathcal{O}(1)\]<p>Without loss of generality we are going to be assume that \(x_n = u\) as it's the worst case.<h3 id=optimal-threshold-l>Optimal Threshold \(l\)</h3><p>To be precise, each integer can be represented as a binary sequence using \(\lceil \log_2 u \rceil\) bits. This representations split this binary sequence into the first \(\lceil \log_2 n \rceil\) bits,called the the higher bits, and the lower \(l = \lceil \log_2 u \rceil - \lceil \log_2 n \rceil \le \left \lceil \log_2 \frac{u}{n} \right \rceil\) bits.<p>The total memory used by elias fano is: \[\mathcal{EF}(u, n) = H + L = n + \left\lfloor \frac{u}{2^l} \right \rfloor + nl + \mathcal{O}(1)\]<p>To find the optimal \(l\) we can just find the critical points of this function in \(l\): \[\frac{\partial}{\partial l} \mathcal{EF}(u, n) = 0 = n + \frac{\partial}{\partial l} \left\lfloor \frac{u}{2^l} \right \rfloor \]<p>For tractability proprouses we are going to approximate this by removing the floor function:<p>\[\frac{\partial}{\partial l} \mathcal{EF}(u, n) = n - \frac{u}{2^l} \ln(2) = 0\]<p>Now we can solve for \(l\):<p>\[\begin{aligned} n - \frac{u}{2^l} \ln(2) &= 0\\ \frac{u}{2^l} \ln(2) &= n\\ \frac{1}{2^l} &= \frac{n}{u\ln(2)}\\ 2^l &= \frac{u\ln(2)}{n}\\ l &= \log_2 \left( \frac{u\ln(2)}{n} \right)\\ l &= \log_2 \left( \frac{u}{n} \right) + \log_2 \left( \ln(2) \right) \approx \log_2 \left( \frac{u}{n} \right) - 0.528766 \\ \end{aligned}\]<p>As a practical approximation we are always going to use:<p>\[l = \left \lceil \log_2 \frac{u}{n} \right \rceil\]<h3 id=elias-fano-memory-usage-mathcal-ef-u-n>Elias-Fano memory usage \(\mathcal{EF}(u, n)\)</h3><p>We can recognize that this is a telescopic series, so we can simplify it by using the definition of high-bits: \[H = n + \left\lfloor \frac{u}{2^l} \right \rfloor = n + \left\lfloor \frac{u}{2^{\left \lceil \log_2 \frac{u}{n} \right \rceil}}\right \rfloor \le n + \frac{u}{2^{\log_2 \frac{u}{n}}} = n + \frac{u}{\frac{u}{n}} = 2n\]<p><em>Note that \(H\) has exactly \(n\) <strong>1s</strong> , this implies that there will be at most \(n\) <strong>0s</strong>. It follows that the optimal data structure to store the array \(H\) it's a simple <a href=https://en.wikipedia.org/wiki/Bit_array>Bitmap</a>.</em><p>So the space used by Elias-Fano \(\mathcal{EF}(u, n)\) is composed by its higher \(H\) and lower \(L\) bits so: \[\mathcal{EF}(u, n) = H + L \le 2n + n \left \lceil \log_2 \frac{u}{n} \right \rceil\]<p>This means that Elias-Fano is asymptotically optimal as: \[\mathcal{EF}(u, n) \le 2n + n \left \lceil \log_2 \frac{u}{n} \right \rceil = n \log_2 \frac{u}{n} + \mathcal{O}(n) \sim_{u, n \to \infty} Z\] Therefore, we can prove that this structure uses at most 2-extra bits for element than the theoretical minimum: \[\mathcal{EF}(u, n) - Z \sim_{u, n \to \infty} 2n - \mathcal{O}(n) \le 2n\] Fano proved a better bound, this encoding uses at most half-bit for element more than the theoretical minimum, so this structure it's not a succint data-structure, but it's really close thus Vigna's name of quasi-succint data-structure.<h3 id=concurrent-reads-and-writes>Concurrent reads and writes</h3><p>We can observe that, while the High-bits are defined on the gaps between successive values, this dependancy can be removed.<p>This proof will be analogous to the one about the space used by the high-bits. The position \(p_j = select(X, j)\) of the \(j\)-th <strong>1</strong> in the high-bits is just the sum of the lengths of all the previous codes: \[p_j = \sum_{0 \le i < j} |\mathcal{U}(h_{i + 1} - h_{i})| = h_j + j\]<p><img alt src=/elias_fano_pibiri.png><p>Therefore we can read and write the elias-fano structure in parallel! For a given tuple \((i, x_i)\) we now that we are going to set the high-bit \(h_i + i\) and write the low-bits in the range \([il, (i+1)l)\).<p>A proper implemetation requires a precise use of atomic instructions, but it's possible to create the index in parallel which can greatley speedup the loading.<h1 id=references>References</h1><ul><li><a href=https://core.ac.uk/download/pdf/79617357.pdf>https://core.ac.uk/download/pdf/79617357.pdf</a><li><a href=https://web.archive.org/web/20160312010342/https://www.computer.org/csdl/proceedings/focs/1989/1982/00/063533.pdf>https://web.archive.org/web/20160312010342/https://www.computer.org/csdl/proceedings/focs/1989/1982/00/063533.pdf</a><li><a href=https://arxiv.org/pdf/1206.4300.pdf>https://arxiv.org/pdf/1206.4300.pdf</a></ul></section></article></main></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>