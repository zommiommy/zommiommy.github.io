<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Storing a set of integers, Elias-Fano, and Graphs (Pt.2) (Draft)
    </title><link href=/corro.svg rel=icon type=image/png><link href=https://zom.wtf/fonts.css rel=stylesheet><link href=/path/to/folder/css/academicons.min.css rel=stylesheet><link href=https://zom.wtf/atom.xml rel=alternate title=zom.wtf type=application/atom+xml><link href=https://zom.wtf/theme/light.css rel=stylesheet><link href=https://zom.wtf/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><img id=title_icon src=/corro.svg><a href=https://zom.wtf>zom.wtf</a><div class=socials><a class=social href=https://twitter.com/zommiommy> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/zommiommy> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/about style=margin-left:.7em>/about</a><a href=/goodstuff style=margin-left:.7em>/good_stuff</a></nav></header><main><article><div class=title><div class=page-header>Storing a set of integers, Elias-Fano, and Graphs (Pt.2) (Draft)</div><div class=meta>Posted on <time>2022-12-20</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://zom.wtf/posts/eliasfano-pt2/#introduction>Introduction</a><li><a href=https://zom.wtf/posts/eliasfano-pt2/#edge-encoding>Edge encoding</a><li><a href=https://zom.wtf/posts/eliasfano-pt2/#properties>Properties</a> <ul><li><a href=https://zom.wtf/posts/eliasfano-pt2/#space-usage>Space usage</a></li><ul><li><a href=https://zom.wtf/posts/eliasfano-pt2/#csr-representation>CSR representation</a><li><a href=https://zom.wtf/posts/eliasfano-pt2/#space-savings-compared-to-a-csr>Space savings compared to a CSR</a><li><a href=https://zom.wtf/posts/eliasfano-pt2/#summary>Summary</a></ul><li><a href=https://zom.wtf/posts/eliasfano-pt2/#out-degree-of-a-node>Out-Degree of a node</a><li><a href=https://zom.wtf/posts/eliasfano-pt2/#neighbours>Neighbours</a></ul><li><a href=https://zom.wtf/posts/eliasfano-pt2/#a-faster-edge-encoding>A faster edge encoding</a></ul><section class=body><h2 id=introduction>Introduction</h2><p>A graph \(G\) is composed of nodes \(V\) and edges \(E \subseteq V \times V\). Without any loss of generality, let's assume that the nodes are integers, it's always possible to define a bijective mapping between nodes and integers.<p><img alt src=/graph.svg><p>\[ E = \left\{ (0, 1), (0, 7), (0, 8), (1, 3), (1, 8), (2, 4), (2, 9), (4, 6), (4, 9), (5, 3), (6, 5), (6, 8),<br> (7, 2), (7, 5), (9, 3) \right\}\]<h2 id=edge-encoding>Edge encoding</h2><p>In order to encode a graph using elias-fano we need to define a bijective-mapping between the edges and integers. There are many possible encodings.<p>\[\phi(src, dst) = \left(src \times |V|\right) + dst\]<p>\[\begin{bmatrix} 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0\\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1\\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0\\ 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\ \end{bmatrix}\]<p>\[\begin{bmatrix} 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\ 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19\\ 20 & 21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29\\ 30 & 31 & 32 & 33 & 34 & 35 & 36 & 37 & 38 & 39\\ 40 & 41 & 42 & 43 & 44 & 45 & 46 & 47 & 48 & 49\\ 50 & 51 & 52 & 53 & 54 & 55 & 56 & 57 & 58 & 59\\ 60 & 61 & 62 & 63 & 64 & 65 & 66 & 67 & 68 & 69\\ 70 & 71 & 72 & 73 & 74 & 75 & 76 & 77 & 78 & 79\\ 80 & 81 & 82 & 83 & 84 & 85 & 86 & 87 & 88 & 89\\ 90 & 91 & 92 & 93 & 94 & 95 & 96 & 97 & 98 & 99\\ \end{bmatrix}\]<p>\[\phi(E) = \begin{bmatrix}1 & 7 & 8 & 13 & 18 & 24 & 29 & 46 & 49 & 53 & 65 & 68 & 72 & 75 & 93 \end{bmatrix}\]<h2 id=properties>Properties</h2><p>To provide real-world examples, in this section I'm going to reference some real world graphs:<table><thead><tr><th>Graph<th># nodes<th># edges<th>Density \(\delta\)<tbody><tr><td><a href=https://law.di.unimi.it/datasets.php>Twitter2010</a><td>41M<td>1.5G<td>\(8.46 \times 10^{-7}\)<tr><td><a href=https://www.wikidata.org/wiki/Wikidata:Main_Page>Wikidata</a><td>1.2G<td>12.4G<td>\(8.61 \times 10^{-9}\)<tr><td><a href=https://law.di.unimi.it/datasets.php>Facebook2011</a><td>0.72G<td>127G<td>\(2.64 \times 10^{-7}\)<tr><td><a href=https://en.wikipedia.org/wiki/Google_Knowledge_Graph>GoogleKG</a><td>5G<td>500G<td>\(2.00 \times 10^{-8}\)</table><h3 id=space-usage>Space usage</h3><p>From the previous post we know that: \[\mathcal{EF}(u, n) \le 2n + n \left \lceil \log_2 \frac{u}{n} \right \rceil\]<p>With this encoding we get:<p>\[\mathcal{EF}(|V|, |E|) \le 2|E| +|E| \left \lceil \log_2 \frac{|V|^2}{|E|} \right \rceil\]<table><thead><tr><th>Graph<th>EF<th>Bits per edge<tbody><tr><td>Twitter2010<td>4.2GB<td>23<tr><td>Wikidata<td>44.95 GB<td>29<tr><td>Facebook2011<td>411.98 GB<td>24<tr><td>GoogleKG<td>1.75 TB<td>28</table><h4 id=csr-representation>CSR representation</h4><p>A CSR representation needs:<p>\[CSR(|V|, |E|) = |V| \left\lceil\log_2|E|\right\rceil + |E| \left\lceil\log_2|V|\right\rceil\]<p>On common implementations, 64-bit integers are used for the cumulative node degrees, and either 32-bit or 64-bit integers depending on the size of the graph, which results in:<table><thead><tr><th>Graph<th>Ideal CSR<th>Bits per edge<th>Real CSR<th>Bits per edge<th>Overhead ratio<tbody><tr><td>Twitter2010<td>4.9GB<td>26.88<td>6.2GB<td>33.8<td>26%<tr><td>Wikidata<td>53.1 GB<td>34.29<td>59.2 GB<td>38.19<td>11%<tr><td>Facebook2011<td>518.30 GB<td>30.19<td>555.1GB<td>32.34<td>7%<tr><td>GoogleKG<td>2.1 TB<td>33.39<td>4 TB<td>64.64<td>93.59%</table><p><em>Note that the GoogleKG has an huge overhead because needing around 34 bits to encode an edge, we are going to use 64-bits, thus we would waste 30 bits.</em><h4 id=space-savings-compared-to-a-csr>Space savings compared to a CSR</h4><p>Space saving comapred to a CSR:<p>\[\begin{align*} CSR(|V|, |E|) - \mathcal{EF}(|V|, |E|) &= |V| \left\lceil\log_2|E|\right\rceil + |E| \left\lceil\log_2|V|\right\rceil - 2|E| - |E| \left \lceil \log_2 \frac{|V|^2}{|E|} \right \rceil\\ &=|V| \left\lceil\log_2|E|\right\rceil + |E| \left( \left\lceil\log_2|V|\right\rceil - 2 - \left \lceil \log_2 \frac{|V|^2}{|E|} \right \rceil\right)\\ &\approx|V| \log_2|E| + |E| \left( \log_2|V| - 2 - \log_2 \frac{|V|^2}{|E|}\right)\\ &\approx|V| \log_2|E| + |E| \left( \log_2|V| - 2 - 2\log_2 |V| + \log_2|E|\right)\\ &\approx|V| \log_2|E| + |E| \left( \log_2|E| - \log_2|V| - 2\right)\\ &\approx|V| \log_2|E| + |E| \log_2 \frac{|E|}{4|V|}\\ \end{align*}\]<p>Therefore, as long as \(|E| \ge 4 |V|\) we are guaranteed to save memory!<p>In practical implementations of CSR, instead of \(\left\lceil\log_2|V|\right\rceil\) most libraries use either \(k = 32\) or \(k = 64\) bits integers. Therefore, if we define the graph "density" as \(\delta = \frac{|E|}{|V|^2}\), we get that: \[ \begin{align*} k &\ge 2 - \left \lceil \log_2 \delta \right \rceil\\ k - 2 &\ge - \left \lceil \log_2 \delta \right \rceil\\ 2 - k &\le \left \lceil \log_2 \delta \right \rceil\\ \frac{1}{2^{k - 2}} &\le \delta\\ \end{align*} \]<p>Therefore for the 32-bit and 64-bit cases we are guaranteed to save memory as long as: \[\delta \ge \frac{1}{2^{30}} \approx 9.32 \times 10^{-10} \qquad \delta \ge \frac{1}{2^{62}} \approx 2.17 \times 10^{-19}\]<h4 id=summary>Summary</h4><table><thead><tr><th>Graph<th>EF<th>Ideal CSR<th>Compression Ratio<th>Real CSR<th>Compression Ratio<tbody><tr><td>Twitter2010<td>4.2 GB<td>4.9 GB<td>16.8%<td>6.2GB<td>47%<tr><td>Wikidata<td>44.95GB<td>53.15GB<td>18.2%<td>59.2GB<td>31%<tr><td>Facebook2011<td>411.98GB<td>518.3GB<td>25.8%<td>555GB<td>35%<tr><td>GoogleKG<td>1.75TB<td>2.1TB<td>19.2%<td>4 TB<td>130%</table><p><em><strong>Elias Fano allows us to save around 20% of memory compared to an ideal CSR and around 35% on a real CSR.</strong></em><h3 id=out-degree-of-a-node>Out-Degree of a node</h3><h3 id=neighbours>Neighbours</h3><h2 id=a-faster-edge-encoding>A faster edge encoding</h2><p>A really simple and fast is to just concatenate the binary representations:<p><img alt src=/edge_encoding.png><p>which mathematically is equivalent to:<p>\[\phi(src, dst) = \left(src \times 2^{\lceil \log_2 |V|\rceil}\right)+ dst\]<pre class=language-rust data-lang=rust style=background:#0f1419;color:#bfbab0><code class=language-rust data-lang=rust><span style=color:#ff7733>fn </span><span style=color:#ffb454>encode_edge</span><span>(</span><span style=color:#f29718>src</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>u64</span><span>, </span><span style=color:#f29718>dst</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>u64</span><span>, </span><span style=color:#f29718>shift</span><span style=color:#bfbab0cc>: </span><span style=color:#ff7733>u64</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#ff7733>u64 </span><span>{
</span><span>    (src </span><span style=color:#f29668><<</span><span> shift) </span><span style=color:#f29668>|</span><span> dst
</span><span>}
</span></code></pre></section></article></main></div><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>